---
title: "GO analysis"
author: "Jason T. Serviss"
date: "09/06/2017"
output:
  html_document:
    code_folding: hide
    highlight: pygments
    theme: readable
---

```{r libraries, message=FALSE}
source('~/Github/diverseScripts/R/scripts/largeDivergingPalettes.R')
library(acidAdaptedRNAseq)
library(GO.db)
library(GOSim)
library(igraph)
library(tidyverse)
library(ggraph)
library(multipanelfigure)
library(grid)
library(gtable)
library(magrittr)
library(printr)
```

```{r, message=FALSE}
#load GO result and subset signignificant terms
data(topGOresult, package = "acidAdaptedRNAseq")
sig <- topGOresult[topGOresult$classicFisher < 0.05, ]
```

Download the GO graph for the significant terms and run the spin-glass community
detection algorithm. Show the number of detected communities and their size.

Note to self: Check if what getGOgraph is downloading is equal to the ancestors 
via GO.db.
```{r, message=FALSE}
#get GO graph
g <- downloadGOgraph(sig$GO.ID)

#run community analysis
tmp <- collapseGraph(g)
cg <- tmp[[1]]
comSummary <- tmp[[2]] %>%
    left_join(select(sig, GO.ID, classicFisher), by=c("GOID" = "GO.ID"))
```

Calculate and show the number of genes included in each community.
```{r}
#calculate genes per term
uCommunityNames <- unique(comSummary$communityName)
genesPerCom <- lapply(1:length(uCommunityNames), function(x) {
    bool <- comSummary$communityName == uCommunityNames[x]
    idsToGet <- comSummary[bool, ]$GOID
    genesForIdsString <- sig[sig$GO.ID %in% idsToGet, "ID"]
    genesForIdsList <- strsplit(genesForIdsString, ", ")
    length(unlist(genesForIdsList))
})
names(genesPerCom) <- uCommunityNames

namedListToTibble(genesPerCom) %>%
    setNames(c("communityName", "nrCommunityGenes")) %>%
    inner_join(distinct(select(comSummary, communityName, communityTerm))) %>%
    select(communityTerm, nrCommunityGenes, -communityName)
```

Show the similarity between communities.
```{r, fig.align='center', fig.height=17, fig.width=15, eval=TRUE, message=FALSE, warning=FALSE}
cgSim <- similarity(cg, mode = "all", method = "jaccard")
colnames(cgSim) <- unique(
    comSummary[match(V(cg)$name, comSummary$communityID), ]$communityTerm
)
rownames(cgSim) <- unique(
    comSummary[match(V(cg)$name, comSummary$communityID), ]$communityTerm
)
heatmap(1 - cgSim, margins = c(20,20))
```

Set attributes in the collapsed graph.
```{r}
cg <- addAttributes1(cg, comSummary)
```

Add back all nodes from the original graph with the exception of the community
nodes. Add an edge from each of the added nodes to the corresponding community
node. Plot the final result.

```{r, fig.align='center', fig.height=17, fig.width=15, eval=TRUE, message=FALSE, warning=FALSE}

#add vertices and edges from uncollapsed graph
toAdd <- comSummary %>%
    filter(!GOID %in% communityID) %>%
    filter(classicFisher < 0.05) %>%
    select(GOID, communityID) %>%
    setNames(c("from", "to"))

cg <- addBackVertexAndEdges(cg, toAdd)

#add attributes
cg <- addAttributes2(cg, comSummary)

#plot
plotCollapsedGraph(cg, 10, 5)
collapsed <- plotCollapsedGraph(cg)
mylegend <- g_legend(collapsed)
collapsed <- collapsed + theme(legend.position="none")
```
