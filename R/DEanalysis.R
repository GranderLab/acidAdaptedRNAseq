#' PCA
#'
#' Performs principal component analysis.
#'
#' This function performs PCA using the genes specified by the \code{ntop}
#' argument and supports 3D plotting of the resulting principal components.
#' The range of \code{PCmin} to \code{PCmax} must include 3 principal
#' components.
#'
#' @name PCA
#' @rdname PCA
#' @author Jason T. Serviss
#' @keywords PCA
#' @param ntop The number of genes with the to include ranked by their variance.
#' @param PCmin The first principal component to return.
#' @param PCmax The last principal component to return.
#' @param plotType A character vector. Can be either \code{plotly} or
#'    \code{scatter3D}.
#'
#' @return Returns a data frame with the PCA results generated by prcomp(). In
#' addition a 3d plot is plotted with the 3 principal components specified by
#' PCmin and PCmax.
#' @examples
#'
#' pca.result <- PCA()
#' #to save the plot use: rgl.postscript("PCAplot","pdf")
#'
#' @export
#' @importFrom plotly plot_ly
#' @importFrom RColorBrewer brewer.pal
#' @importFrom car scatter3d
#' @importFrom rgl rgl.viewpoint
#' @importFrom stats prcomp

PCA <- function(ntop = 500, PCmin = 1, PCmax = 3, plotType = "plotly") {

  x <- DESeq2rld.HCT116
  
  ##perform PCA
  rv = apply(x, 1, var)
  select = order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  pca = prcomp(t(x[select,]), center=FALSE, scale=FALSE)
  
  ##extract information and annotate for plotting
  scores <- data.frame(pca$x[, PCmin:PCmax])
  scores$sample <- rownames(scores)
  scores$group <- gsub("(*.)[A,B,C]", "\\1", scores$sample)
  
  ##plot and return
  pca.result <- .plotPCAType(plotType, scores, pca)
  
  return(pca.result)
}


.plotPCAType <- function(plotType, scores, pca) {
  if(plotType == "plotly") {
    scores$color =
      ifelse(scores$group == "HT116.parental", "red",
      ifelse(scores$group == "HT116.adapted", "darkorchid4",
      ifelse(scores$group == "Me.parental", "blue", "aquamarine")))
    
    p <- plotly::plot_ly(scores, x = ~PC1, y = ~PC2, z= ~PC3,
      text = paste("Sample: ", scores$sample),
      type="scatter3d",
      mode="markers",
      split = ~group
    )
    
    pca.result <- list("plot" = p,
      "pca.sdev" = pca$sdev,
      "pca.rotation" = pca$rotation,
      "pca.center" = pca$center,
      "pca.scale" = pca$scale,
      "pca.x" = pca$x,
      "scores" = scores
    )
    
    return(pca.result)

  } else {
    colors <- RColorBrewer::brewer.pal(n=7, name="Dark2")
    car::scatter3d(scores$PC1,
      scores$PC2,
      scores$PC3,
      groups = as.factor(scores$group),
      grid = FALSE,
      surface.col = colors,
      surface=FALSE,
      xlab="PC1",
      ylab="PC2",
      zlab="PC3",
      axis.scales = FALSE
    )
    
    rgl::rgl.viewpoint(theta = 0, phi = 0, fov = 60, zoom=1)
     
    pca.result <- list(
      "pca.sdev" = pca$sdev,
      "pca.rotation" = pca$rotation,
      "pca.center" = pca$center,
      "pca.scale" = pca$scale,
      "pca.x" = pca$x,
      "scores" = scores
    )
    
    return(pca.result)
  }
}

#' PCvar
#'
#' Plots the percentage of variance in each principal component
#'
#' This function allows plotting of the percentage of variance distributed throughout the
#' principal components for PCAs generated with the PCA function. A red line is drawn at the
#' level of variance contributed by each principal component if each principal component
#' contributed an equal amount of variance.
#'
#'
#' @name PCvar
#' @rdname PCvar
#' @author Jason T. Serviss
#' @keywords PCA, PCvar
#' @examples
#'
#' PCvar(x = "all", ntop = 500)
#'
#' @export
#' import ggplot2
#' import ggthemes theme_few()

PCvar <- function(x) {
    sd <- as.data.frame(x$pca.sdev)
    var <- sd[ ,1:1]^2
    var.percent <- var/sum(var) * 100
  
    dat <- data.frame(
        var.perc = var.percent,
            PC = factor(
                paste("PC", 1:length(var.percent), sep=""),
                levels=colnames(x$pca.x)),
        stringsAsFactors=TRUE
    )
  
    label <- strtrim(as.character(var.percent), 6)
  
    p <- ggplot(dat, aes(x=PC, y=var.perc))+
        geom_bar(stat="identity")+
        geom_text(aes(label=label), size=3, vjust=-1)+
        xlab("Principal Component")+
        ylab("Percent Variance")+
        ggtitle("Percent Variance per Principal Component")+
        ggthemes::theme_few()
    p
    return(p)
}

#' topGO
#'
#' Runs GO analysis using topGO.
#'
#' @name topGO
#' @rdname topGO
#' @author Jason T. Serviss
#' @param save Logical. Indicates if the results should be
#'    saved to ./data/topGOresult.rda.
#' @keywords topGO
#' @examples
#'
#' x <- topGO()
#'
#' @export
#' @import topGO
#' @import plyr
#' @import biomaRt

topGO <- function(save=TRUE) {
  
  ##subset gene universe which is comprised of all quantified genes for the cell type.
  allGenes = .universe()
  
  ##get DE genes
  #tmp <- annotateOverlap()
  #DE <- tmp$ID
  
  #only use DE in HCT116 found with DESeq2
  DE <- DESeq2.HCT116[DESeq2.HCT116$padj < 0.05, "ID"]
  
  
  ##runGO
  GO = .runGO(DE = DE, universe = allGenes)
  
  ##get full GO names
  ensembl = useMart("ensembl",dataset="hsapiens_gene_ensembl")
  go <- getBM(attributes=c('go_id', 'name_1006'), mart = ensembl)
  GO <- merge(GO, go, by.x="GO.ID", by.y="go_id", all.x=TRUE, all.y=FALSE)
  GO$name_1006[is.na(GO$name_1006)] <- GO$Term[is.na(GO$name_1006)]
  GO$Term <- GO$name_1006
  GO$name_1006 <- NULL
  
  ##check coverage
  .Pcoverage(GO, DE)
  
  if(save) {
      save(GO, file="data/topGOresult.rda", compress = "bzip2")
  }
  
  return(GO)
}


#####################units#######################
.universe <- function(cellType) {
    IDs <- unique(c(DESeq2.HCT116$ID, DESeq2.Me$ID))
}

.runGO <- function(DE, universe) {
    ##reformat DE results for topGO
    geneList <- factor(as.integer(universe %in% DE))
    names(geneList) <- universe
  
    ##run GO
    GOdata<- new(
        "topGOdata",
        ontology = "BP",
        allGenes = geneList,
        nodeSize = 5,
        annot = annFUN.org,
        mapping = "org.Hs.eg.db",
        ID = "Ensembl"
    )
    
    resultFisher <- runTest(
        GOdata,
        algorithm = "classic",
        statistic = "fisher"
    )
    
    outTmp <- GenTable(
        GOdata,
        classicFisher = resultFisher,
        topNodes = 1000
    )
    
    outTmp2 <- subset(outTmp, classicFisher < 1)
  
    ##annotate genes associated with reported GO terms
    allGO = genesInTerm(GOdata) ###gets all genes related to go terms
    newGO = .namedListToDF(x = allGO, y = DE)
  
  
    ##merge GO results to include the genes involved in the GO terms
    merg = merge(outTmp2, newGO, by = "GO.ID", all.x = TRUE)
    merg = merg[order(merg$classicFisher), ]
    return(merg)
}

##for use with the runGO function.
#Turns a named list of unequal length into a data frame.
#This also annotates gene name from given gene ID.

.namedListToDF <- function(x, y) {
  out = data.frame()
  
  for( tt in 1:length(x) ) {
    merg <- data.frame()
    curr = x[tt]
    name = names(curr)
    INvalues = data.frame(ID = unlist(strsplit(curr[[1]], ", ")))
    merg = merge(DeMilitoRNAseq::annotation, INvalues, by="ID", all.y=TRUE)
    subs <- merg[merg$ID %in% y, ]
    out[tt, "GO.ID"] <- name
    out[tt, "gene_name"] <- ifelse(
        nrow(subs) == 0,
        NA,
        paste(subs$geneName, collapse = ", ")
    )
    out[tt, "ID"] <- ifelse(
        nrow(subs) == 0,
        NA,
        paste(subs$ID, collapse = ", ")
    )
    out[tt, "biotype"] <- ifelse(
        nrow(subs) == 0,
        NA,
        paste(subs$biotype, collapse = ", ")
    )
  }
  return(out)
}

##calculate coverage. for use with the runGO function.
.Pcoverage <- function(x, interesting) {
    
    output <- data.frame()
    
    ##calculate number of significant GO terms
    sig.nr <- nrow(subset(x, classicFisher < 0.05))
    ##calculate most significant GO term
    most.sig <- min(x$classicFisher)
    return <- unique(unlist(strsplit(x$ID, ", ")))
  
    ##calculate coverage and print output
    final <- unique(return)
    found <- final[final %in% interesting]
    percent <- (length(final) / length(interesting))*100

    print("% coverage:")
    print(percent)
    print("total DE genes:")
    print(length(interesting))
    print("genes in GO:")
    print(length(final))
    print("nr. significant GO terms:")
    print(sig.nr)
    print("most significant term:")
    print(most.sig)
    cat("\n")
  
    return(output)
}

#' MAplot
#'
#' Plot an MA plot (average expression vs. log2 fold change) using the results
#' from the DESeq2 differential expression analysis.
#'
#' @name MAplot
#' @rdname MAplot
#' @author Jason T. Serviss
#' @keywords MAplot
#' @examples
#'
#' MAplot()
#'
#' @export
#' @importFrom tibble as_tibble
#' @importFrom dplyr select
#' @import ggplot2
#' @import ggthemes

MAplot <- function() {
    data <- DESeq2.HCT116 %>%
        as_tibble() %>%
        select(baseMean, log2FoldChange)

    p <- ggplot(data, aes(log2(baseMean), log2FoldChange))+
        geom_point(alpha=0.1)+
        ggthemes::theme_few()+
        labs(
            x="log2(base mean)",
            y="log2(fold change)",
            title="MA plot",
            subtitle="Red lines correspond to a fold change of 2."
        )+
        ylim(-6,6)+
        geom_hline(yintercept=1, colour="red", lty=2)+
        geom_hline(yintercept=-1, colour="red", lty=2)+
        theme(
            plot.subtitle=element_text(size=10)
        )

    p
    return(p)

}

#' volcanoPlot
#'
#' Plot an volcano plot using the results from the DESeq2 differential
#' expression analysis using only significant (alpha < 0.05) genes.
#'
#' @name MAplot
#' @rdname MAplot
#' @author Jason T. Serviss
#' @param n Numeric. The number of gene names to plot based on their log2 fold
#'    change.
#' @keywords MAplot
#' @examples
#'
#' MAplot()
#'
#' @export
#' @importFrom tibble as_tibble
#' @importFrom dplyr select filter bind_row
#' @import ggplot2
#' @import ggthemes

volcanoPlot <- function(n=5) {
    data <- DESeq2.HCT116 %>%
        as_tibble() %>%
        filter(padj < 0.05) %>%
        select(log2FoldChange, padj)
        
    genesTop <- DESeq2.HCT116 %>%
        as_tibble() %>%
        filter(padj < 0.05) %>%
        arrange(desc(log2FoldChange)) %>%
        head(n=n) %>%
        select(log2FoldChange, padj, geneName)
        
    genesBottom <- DESeq2.HCT116 %>%
        as_tibble() %>%
        filter(padj < 0.05) %>%
        arrange(log2FoldChange) %>%
        head(n=n) %>%
        select(log2FoldChange, padj, geneName)
        
    genes <- dplyr::bind_rows(genesTop, genesBottom)
    
    p <- ggplot(data, aes(log2FoldChange, -log10(padj)))+
        geom_point(alpha=0.1)+
        geom_text(
            data=genes,
            aes(x=log2FoldChange, y=-log10(padj), label=geneName),
            nudge_y=1
        )+
        ggthemes::theme_few()+
        geom_vline(xintercept=-1, colour="red", lty=2)+
        geom_vline(xintercept=1, colour="red", lty=2)+
        labs(
            x="log2(fold change)",
            y="-log10(p-value)",
            title="Volcano plot",
            subtitle="Red lines represent a fold change of 2."
        )+
        theme(
            plot.subtitle=element_text(size=10)
        )
    p
    return(p)

}

