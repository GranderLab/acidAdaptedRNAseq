#' PCA
#'
#' Performs principal component analysis.
#'
#' This function performs PCA using the genes specified by the \code{ntop}
#' argument and supports 3D plotting of the resulting principal components.
#' The range of \code{PCmin} to \code{PCmax} must include 3 principal
#' components.
#'
#' @name PCA
#' @rdname PCA
#' @author Jason T. Serviss
#' @keywords PCA
#' @param ntop The number of genes with the to include ranked by their variance.
#' @param PCmin The first principal component to return.
#' @param PCmax The last principal component to return.
#' @param plotType A character vector. Can be either \code{2D}, \code{plotly} or
#'    \code{scatter3D}.
#'
#' @return Returns a data frame with the PCA results generated by prcomp(). In
#' addition a 3d plot is plotted with the 3 principal components specified by
#' PCmin and PCmax.
#' @examples
#'
#' pca.result <- PCA()
#' #to save the plot use:
#' \dontrun{rgl.postscript("PCAplot","pdf")}
#'
#' @export
#' @importFrom plotly plot_ly
#' @importFrom RColorBrewer brewer.pal
#' @importFrom car scatter3d
#' @importFrom rgl rgl.viewpoint
#' @importFrom stats prcomp var
#' @import ggplot2
#' @importFrom ggthemes theme_few scale_colour_ptol
NULL

PCA <- function(ntop = 500, PCmin = 1, PCmax = 3, plotType = "2D") {

  x <- deResultsRld
  
  ##perform PCA
  rv = apply(x, 1, var)
  select = order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  pca = prcomp(t(x[select,]), center=FALSE, scale=FALSE)
  
  ##extract information and annotate for plotting
  scores <- data.frame(pca$x[, PCmin:PCmax])
  scores$sample <- rownames(scores)
  scores$group <- gsub("(*.)[A,B,C]", "\\1", scores$sample)
  
  ##plot and return
  pca.result <- .plotPCAType(plotType, scores, pca)
  
  return(pca.result)
}


.plotPCAType <- function(plotType, scores, pca) {
    
    pca.result <- list("plot" = p,
        "pca.sdev" = pca$sdev,
        "pca.rotation" = pca$rotation,
        "pca.center" = pca$center,
        "pca.scale" = pca$scale,
        "pca.x" = pca$x,
        "scores" = scores
    )
    if(plotType == "plotly") {
        scores$color =
            ifelse(scores$group == "HT116.parental", "red",
            ifelse(scores$group == "HT116.adapted", "darkorchid4",
            ifelse(scores$group == "Me.parental", "blue", "aquamarine"
        )))
    
        p <- plot_ly(scores, x = ~PC1, y = ~PC2, z= ~PC3,
            text = paste("Sample: ", scores$sample),
            type="scatter3d",
            mode="markers",
            split = ~group
        )
        p
    
        return(list(p, pca.result))

    } else if(plotType == "scatter3D"){
        colors <- brewer.pal(n=7, name="Dark2")
        scatter3d(scores$PC1,
            scores$PC2,
            scores$PC3,
            groups = as.factor(scores$group),
            grid = FALSE,
            surface.col = colors,
            surface=FALSE,
            xlab="PC1",
            ylab="PC2",
            zlab="PC3",
            axis.scales = FALSE
        )
    
        rgl.viewpoint(theta = 0, phi = 0, fov = 60, zoom=1)
    
        return(pca.result)
    } else {
        p <- ggplot(scores, aes_string('PC1', 'PC2'))+
            geom_point(aes_string(colour='group'), size=7, alpha=0.8)+
            theme_few()+
            scale_color_ptol(labels=c("Adapted", "Parental"))+
            guides(colour=guide_legend(title="Condition"))+
            labs(
                x="Principal component 1",
                y="Principal component 2",
                title="Principal component analysis"
            )
        p
        return(pca.result)
    }
}

#' PCvar
#'
#' Plots the percentage of variance in each principal component
#'
#' This function allows plotting of the percentage of variance in the
#' principal components for PCAs generated with the PCA function. A red line is
#' drawn at the level of variance contributed by each principal component if
#' each principal component contributed an equal amount of variance.
#'
#'
#' @name PCvar
#' @rdname PCvar
#' @author Jason T. Serviss
#' @keywords PCA, PCvar
#' @param x Output from the PCA function.
#' @examples
#' pca <- PCA()
#' PCvar(pca)
#'
#' @export
#' @import ggplot2
#' @importFrom ggthemes theme_few
NULL

PCvar <- function(x) {
    sd <- as.data.frame(x$pca.sdev)
    var <- sd[ ,1:1]^2
    var.percent <- var/sum(var) * 100
  
    dat <- data.frame(
        var.perc = var.percent,
        PC = factor(
            paste("PC", 1:length(var.percent), sep=""),
            levels=colnames(x$pca.x)
        ),
        stringsAsFactors=TRUE
    )
  
    label <- strtrim(as.character(var.percent), 6)
  
    p <- ggplot(dat, aes_string(x='PC', y='var.perc'))+
        geom_bar(stat="identity")+
        geom_text(aes_string(label='label'), size=3, vjust=-1)+
        xlab("Principal Component")+
        ylab("Percent Variance")+
        ggtitle("Percent Variance per Principal Component")+
        theme_few()
    p
    return(p)
}

#' MAplot
#'
#' Plot an MA plot (log 2 average expression vs. log2 fold change) using the
#' results from the DESeq2 differential expression analysis.
#'
#' @name MAplot
#' @rdname MAplot
#' @author Jason T. Serviss
#' @keywords MAplot
#' @examples
#'
#' MAplot()
#'
#' @export
#' @importFrom tibble as_tibble
#' @importFrom dplyr select_
#' @import ggplot2
#' @importFrom ggthemes theme_few
#' @importFrom magrittr %>%
NULL

MAplot <- function() {
    data <- deResults %>%
        as_tibble() %>%
        select_(~baseMean, ~log2FoldChange)

    p <- ggplot(data, aes_string('log2(baseMean)', 'log2FoldChange'))+
        geom_point(alpha=0.1)+
        theme_few()+
        labs(
            x="log2(base mean)",
            y="log2(fold change)",
            title="MA plot",
            subtitle="Red lines correspond to a fold change of 2."
        )+
        ylim(-6,6)+
        geom_hline(yintercept=1, colour="red", lty=2)+
        geom_hline(yintercept=-1, colour="red", lty=2)+
        theme(
            plot.subtitle=element_text(size=10)
        )

    p
    return(p)

}

#' volcanoPlot
#'
#' Plot an volcano plot using the results from the DESeq2 differential
#' expression analysis using only significant (alpha < 0.05) genes.
#'
#' @name volcanoPlot
#' @rdname volcanoPlot
#' @author Jason T. Serviss
#' @param n Numeric. The number of gene names to plot based on their log2 fold
#'    change.
#' @keywords volcanoPlot
#' @examples
#'
#' volcanoPlot()
#'
#' @export
#' @importFrom tibble as_tibble
#' @importFrom dplyr select_ filter_ bind_rows arrange_ desc
#' @import ggplot2
#' @importFrom ggthemes theme_few
#' @importFrom utils head
#' @importFrom magrittr %>%
NULL

volcanoPlot <- function(n=5) {
    data <- deResults %>%
        as_tibble() %>%
        filter_(~padj < 0.05) %>%
        select_(~log2FoldChange, ~padj)
        
    genesTop <- deResults %>%
        as_tibble() %>%
        filter_(~padj < 0.05) %>%
        arrange_(~desc(log2FoldChange)) %>%
        head(n=n) %>%
        select_(~log2FoldChange, ~padj, ~geneName)
        
    genesBottom <- deResults %>%
        as_tibble() %>%
        filter_(~padj < 0.05) %>%
        arrange_(~log2FoldChange) %>%
        head(n=n) %>%
        select_(~log2FoldChange, ~padj, ~geneName)
        
    genes <- bind_rows(genesTop, genesBottom)
    
    p <- ggplot(data, aes_string('log2FoldChange', '-log10(padj)'))+
        geom_point(alpha=0.1)+
        geom_text(
            data=genes,
            aes_string(x='log2FoldChange', y='-log10(padj)', label='geneName'),
            nudge_y=1
        )+
        theme_few()+
        geom_vline(xintercept=-1, colour="red", lty=2)+
        geom_vline(xintercept=1, colour="red", lty=2)+
        labs(
            x="log2(fold change)",
            y="-log10(p-value)",
            title="Volcano plot",
            subtitle="Red lines represent a fold change of 2."
        )+
        theme(
            plot.subtitle=element_text(size=10)
        )+
        xlim(
            max(range(data$log2FoldChange))*-1,
            max(range(data$log2FoldChange))
        )
    p
    return(p)

}

